# 09.23

# <div style="background-color: yellow;">App Router</div>

> [페이지 라우터와의 차이]<br/>
>
> - 데이터 페칭 방식 변경
> - 레이아웃 설정 방식 변경
> - 페이지 라우팅 설정 방식 변경
> - 리액트 18 (서버컴포넌트, 스트리밍 사용 가능)
>
> [페이지 라우터 같은 것]<br/>
>
> - 네비게이팅
> - 프리페칭
> - 사전렌더링

## 🚀 Installation

```terminal
$ npx create-next-app@rc [project-name] // 출시 후보 버전 (15)
$ npx create-next-app@latest [project-name] // 정식 출시 버전

typescrpt
eslint
tailwindCSS
/src
App Router
Turbopack (No)
import alias (No)
```

## 🚀 Folder Structure

### /src/app

- page.tsx 가 페이지 역할을 하는 컴포넌트
- layout.tsx 가 레이아웃 역할을 하는 컴포넌트

## 🚀 페이지 라우팅 설정

> /app 폴더 기반 <br/>
> "/search" 경로는 /search 폴더 안에 page.tsx <br/>
> "/search/:id" 경로는 /search 폴더 안에 /[id] 폴더 안에 page.tsx

### "/search" 페이지 <br/>

| 📌 app-router NextJS에서 URL Params나 Query String은 컴포넌트의 props에 담겨있다. ( params, searchParams )

```tsx
export default function Page({
  searchParams,
}: {
  searchParams: { q?: string };
}) {
  return <div>Search 페이지 : {searchParams.q}</div>;
}
```

### "/book/1", "/book/2", "/book/3" 페이지 ("/book/:id") <br/>

```tsx
export default function Page({
  params,
}: {
  params: { id: string | string[] };
}) {
  return <div>Book [id] 페이지 : params.id</div>;
}
```

### "/book/1/2", "/book/100/200" 페이지 (catch all segement) <br/>

| /src/app/book/[...id]

```tsx
export default function Page({
  params,
}: {
  params: { id: string | string[] };
}) {
  return <div></div>;
}
```

### "/book", "/book/100/200" 페이지 (optional catch all segement) <br/>

| /src/app/book/[[...id]]

```tsx
export default function Page({
  params,
}: {
  params: { id: string | string[] };
}) {
  return <div></div>;
}
```

## 🚀 레이아웃 설정

> [ "/search"로 시작하는 모든 페이지의 레이아웃 ] <br/>
> /search 폴더 안에 layout.tsx 생성

## 🚀 중첩 레이아웃

> [ /search 폴더 안에 layout.tsx 그리고 /search 폴더 안에 /setting 폴더 안에 layout.tsx ] <br/>
> /search 폴더의 layout.tsx와 /setting 폴더 안에 layout.tsx 레이아웃 2개가 중첩되서 /setting 폴더 안 page.tsx에 적용된다.

## 🚀 루트 레이아웃

> /src/app 폴더에 layout.tsx

```tsx
import type { Metadata } from "next";
import localFont from "next/font/local";
import "./global.css";

const geistSans = localFont({
  src: "./fonts/GeistVF.woff",
  variable: "--font-geist-sans",
});
const geistMono = localFont({
  src: "./font/GeistMonoVF.woff",
  variable: "--font-geist-mono",
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{ children: React.ReactNode }>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable}`}>
        {children}
      </body>
    </html>
  );
}
```

## 🚀 특정 페이지에만 적용되는 공통 레이아웃 : Route Group

| (소괄호로 감싼 폴더) 경로에 영향을 주지 않는 폴더

> /src/app/(with-searchbar) <br/>
> 📌 소괄호 폴더 안에 layout.tsx를 만들면 폴더 안의 컴포넌트들의 레이아웃을 설정한다.

<br/><br/><br/>

# <div style="background-color: yellow;">서버 컴포넌트</div>

> 서버 측에서만 실행되는 컴포넌트 ( 브라우저에서 실행 X )

## 📌 NextJS 렌더링 과정

1. 사용자가 특정 페이지에 접근하면, 브라우저에서 해당 페이지로 요청을 보낸다.
2. NextJS 서버가 요청을 받고 해당 페이지를 서버에서 렌더링
3. getServerSideProps 함수를 실행(next13)해서 데이터를 페칭하거나 인증 로직을 처리하고 페이지 컴포넌트로 데이터를 전달
4. 페이지 컴포넌트를 서버에서 렌더링한다. ( React 컴포넌트가 HTML 변환됨 )
5. 생성된 HTML이 브라우저로 전송된다.
6. HTML을 브라우저에 렌더링하고 Javascript 코드를 다운로드하여 기존 HTML과 연결하는 Hydration을 진행
   📌 Hydration 과정에서 다운로드 되는 Javascript 코드 중에 인터렉션이 필요없는 정적 컴포넌트는 서버에서 HTML로 변환만 하면 되는데 불필요하게 다운로드 된다. ( 서버 컴포넌트로 해결 )

1️⃣ 서버 컴포넌트 : 서버 측에서 사전 렌더링을 진행할 때 한번만 실행 <br/>
2️⃣ 클라이언트 컴포넌트 : 사전 렌더링을 진행할 때 한번, Hydration을 진행할 때 한번 총 2번 실행 <br/>
✅ 페이지 대부분을 서버 컴포넌트로 구성하고 꼭 필요한 경우에 클라이언트 컴포넌트를 사용할 것을 권장

### 서버 컴포넌트

> app-router에서는 기본적으로 컴포넌트가 서버 컴포넌트로 생성되므로 따로 설정이 필요하진 않다.

```tsx
export default function Home() {
  // ✅ 기본적으로 서버 컴포넌트로 생성되기 때문에 보안적인 작업이나 데이터 페칭 작업을 해도 된다. (브라우저에서 실행 X)
  const SECRET_KEY = "AKDFJEJ123DK";

  // ❌ 서버 컴포넌트이기 때문에 브라우저 실행되어야 하는 기능들은 사용할 수 없다. ( 리액트 Hooks )
  useEffect(() => {
    console.log("서버 컴포넌트여서 에러가 발생합니다.");
  }, []);

  return (
    <>
      <div>인덱스 페이지</div>
    </>
  );
}
```

### 클라이언트 컴포넌트 ('use client')

> 상호 작용이 있어야하면 클라이언트 컴포넌트로 만들면 된다.

```tsx
"use client";

export default function Home() {
  useEffect(() => {
    // 📌 사전 렌더링 시에 1번, Hydration 시에 또 1번 실행되서 총 2번 콘솔이 찍힌다.
    console.log(
      "use client를 사용해서 클라이언트 컴포넌트로 만들어서 브라우저 콘솔이 찍힌다."
    );
  }, []);

  return (
    <>
      <div>인덱스 페이지</div>
    </>
  );
}
```

### 상호 작용 정리

- 리스트 페이지는 서버 컴포넌트 ( 리스트 클릭 페이지 이동은 HTML 고유의 기능이여서 상호 작용이 아니다. )
- 검색 인풋 컴포넌트는 클라이언트 컴포넌트 ( 실시간으로 입력하는 값으로 상태값을 업데이트 )

📌 서버 컴포넌트: 서버에서 데이터를 렌더링하거나, 브라우저에서 자바스크립트 실행이 필요 없는 경우에 사용 <br/><br/>
📌 클라이언트 컴포넌트:

- 사용자 상호작용(클릭, 입력 등)을 처리하거나, 상태 관리가 필요한 경우 <br/>
- useRouter와 같이 클라이언트 측 동작이 필요한 API를 사용할 때.
